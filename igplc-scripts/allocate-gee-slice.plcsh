#!/usr/bin/plcsh
# Run as ./get-gee-tarball.plcsh -- <args>


import sys
import os
import re
import tarfile
import argparse
import json
import time
import datetime
from StringIO import StringIO
from django.core.validators import validate_email

keydir='/usr/share/keydir'
tardir='/tmp/GEE'

if 'GEE_CONFIG_FILE' in os.environ:
    execfile(os.environ['GEE_CONFIG_FILE'])
else:
    execfile('./config.py')

fabfile=user_script_path+'/fabfile.py'
readme=user_script_path+'/README.txt'
network=user_script_path+'/network.py'


parser = argparse.ArgumentParser(description='Get the tarball for a new GEE slice')
parser.add_argument('-e','--email',
                    help='Email address of the user for this slice', 
		    required=True)



args = parser.parse_args()
# execfile(args.config)
# Check that the email address looks valid
try:
    validate_email(args.email)
except:
    sys.exit("ERROR: %s is not a valid email address!" % args.email)

# Disallow the fake email addresses that mark the account as unused
if re.match(ig_names['email_wildcard_string'], args.email):
    sys.exit("ERROR: email address %s is not allowed!" % args.email)

# Make sure the email address is not already in use for GEE
inuse = GetPersons({'email':args.email})
if inuse:
    sys.exit("ERROR: email address %s already in use on InstaGENI-PlanetLab" % args.email)

# Choose a free user account and mark it as allocated
# A free account will have anig_names['email_wildcard_string']address
allegedlyFree = GetPersons({'email':ig_names['email_wildcard_string']})
free = []
for person in allegedlyFree:
    if len(GetSlices(person['slice_ids'])) > 0:
          free.append(person)

if not free:
    sys.exit("ERROR: no GEE slices available!")

# Associate the email address with the slice's user
alloc = free[0]
# print ("Using person %s" % alloc['email'])
# print alloc
UpdatePerson(alloc['person_id'], {'email':args.email})

# Create the tarball
slice = GetSlices(alloc['slice_ids'])[0]
# print slice
keyfile = keydir + '/%s.pem' % slice['name']
tarball = tardir + '/%s.tar' % slice['name']

if not os.path.exists(tardir):
    os.makedirs(tardir)

try:
    os.remove(tarball)
except OSError:
    pass

tar = tarfile.open(tarball, 'w')
for name in [keyfile, readme, network]:
    arcname = os.path.split(name)[1]
    tar.add(name, arcname=arcname)

# Fix up fabfile.py template
with open(fabfile, "r") as f:
     fab = f.read()
fab = re.sub("%SLICE%", slice['name'], fab)

hosts = [x['hostname'] for x in slice_nodes]
fab = re.sub("%HOSTS%", "%s" % hosts, fab)

idx = 1
slivers = []
labels = []
for node in slice_nodes:
    slivers.append({'host': node['hostname'], 'addr': '10.128.234.%d' % idx})
    labels.append("%s = 10.128.234.%d" % (node['label'], idx))
    idx += 1
    
fab = re.sub("%SLIVERS%", "%s" % slivers, fab)

ti = tarfile.TarInfo("fabfile.py")
ti.size = len(fab)
ti.mtime = time.time()
tar.addfile(ti, StringIO(fab))

network = '\n'.join(labels)
ti = tarfile.TarInfo("network.py")
ti.size = len(network)
ti.mtime = time.time()
tar.addfile(ti, StringIO(network))

tar.close()

#
# Set the expiry time of the slice.  Warning!  Warning! Warning!  Not Tested!
#
now = int(time.time()) # right now, in seconds
two_weeks = 3600 * 24 * 7 * 2 # 3600 s/h * 24 h/d * 7 d/w * 2 w
expires = now + two_weeks
UpdateSlice(slice['slice_id'], {'expires':expires})

# Return the email, expiry time, slice name, and the tarball, in JSON format
print json.dumps({'user': args.email, 'slicelet_file': tarball, 'expires': expires, 'slice':slice})
#print tarball


