//Copyright (c) 2014 US Ignite 
// 
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
//and/or hardware specification (the “Work”) to deal in the Work without restriction, including 
//without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
//sell copies of the Work, and to permit persons to whom the Work is furnished to do so, subject to 
//the following conditions: 
// 
//The above copyright notice and this permission notice shall be included in all copies or 
//substantial portions of the Work. 
// 
//THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
//OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS 
//IN THE WORK.

/* Main webserver for the GENI Experiment Engine Compute Engine.  Major
 * Functions: Get  a Slicelet (/get_slicelet), Free a Slicelet (/free_slicelet)
 * renew a slicelet /renew_slicelet, to be written
 * Node server (of course.  Run as node app1.js)
 * Uses passport for authentication, currently calling back to Google
 */

var express = require("express");
var passport = require('passport')
  , GoogleStrategy = require('passport-google-oauth').OAuth2Strategy;

// Passport session setup.
//   To support persistent login sessions, Passport needs to be able to
//   serialize users into and deserialize users out of the session.  Typically,
//   this will be as simple as storing the user ID when serializing, and finding
//   the user by ID when deserializing.  However, since this example does not
//   have a database of user records, the complete Google profile is
//   serialized and deserialized.
passport.serializeUser(function(user, done) {
  done(null, user);
});

passport.deserializeUser(function(obj, done) {
  done(null, obj);
});

/*
 * Initialize node and parameters we will need.
 */

var url = require('url');
var http = require('http');
var app = express();
// the host and port we are running on, and the URL for people to request
var host_name = 'igplc.cs.princeton.edu'
application_port = 8080
var application_url = 'http://' + host_name + ':' + application_port;
// configure node.  We'll use Jade for templating and put the templates in view.
// We will parse cookies and query bodies, and route queries
app.configure(function() {
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');
  app.use(express.static(__dirname + '/public'));
  app.use(express.logger());
  app.use(express.cookieParser());
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(express.session({ secret: 'keyboard cat' }));
  // Initialize Passport!  Also use passport.session() middleware, to support
  // persistent login sessions (recommended).
  app.use(passport.initialize());
  app.use(passport.session());
  app.use(app.router);
});
//
// show the stack when we debug; when we are in production use the error handler.
app.configure('development', function(){
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));

});

app.configure('production', function(){
  app.use(express.errorHandler());
});

// Initialize the server
var server = app.listen(application_port, function() {
    console.log('Listening on port %d', server.address().port);
});

// JSON for Google authentication, generated by Google from the API Dashboard.

var google_settings = {"web":{"auth_uri":"https://accounts.google.com/o/oauth2/auth","client_secret":"i7ayBePRqdrRm_zlN4sq2Yli","token_uri":"https://accounts.google.com/o/oauth2/token","client_email":"473568257016-cjcdk0t42tcgmo09gk9hkichjdd3lu3h@developer.gserviceaccount.com",
"redirect_uris":["http://www.gee-project.org:8080/oauth2callback", "http://igplc.cs.princeton.edu:8080/oauth2callback"],"client_x509_cert_url":"https://www.googleapis.com/robot/v1/metadata/x509/473568257016-cjcdk0t42tcgmo09gk9hkichjdd3lu3h@developer.gserviceaccount.com",
"client_id":"473568257016-cjcdk0t42tcgmo09gk9hkichjdd3lu3h.apps.googleusercontent.com","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs",
"javascript_origins":["http://www.gee-project.org:8080", "http://igplc.cs.princeton.edu:8080"]}};


var secret = google_settings.web.client_secret;
var client_id = google_settings.web.client_id;
var redirect = application_url + "/oauth2callback";
// user_email is the identity we are going to pull back from Google
var user_email;

// Set up the authentication logic.  The last element is a callback
passport.use(new GoogleStrategy({
    clientID: client_id,
    clientSecret: secret,
    callbackURL: redirect,
    scope: 'https://www.googleapis.com/auth/userinfo.email'
  },
  function(accessToken, refreshToken, profile, done) {
    /* User.findOrCreate({ googleID: profile.id}, function(err, user) {
      done(err, user);
    }); */
    // asynchronous verification, for effect...
    process.nextTick(function () {
      
      // To keep the example simple, the user's Google profile is returned to
      // represent the logged-in user.  In a typical application, you would want
      // to associate the Google account with a user record in your database,
      // and return that user instead.
      console.log(JSON.stringify(profile));
      user_email = profile.emails[0].value;
      console.log(JSON.stringify(user_email));
      return done(null, profile);
    });
  }
));

//
// Google callback

app.get('/auth/google', passport.authenticate('google'));
// Google will redirect the user to this URL after authentication.  Finish
// the process by verifying the assertion.  If valid, the user will be
// logged in.  Otherwise, authentication has failed.
app.get('/oauth2callback',
  passport.authenticate('google', { successRedirect: '/logged_in',
                                    failureRedirect: '/login_failure' }));

// The greeting page is the login page

app.get('/', function(req, res) {
    res.render('login');
});

// Redirect here on failure.  This page will permit the user to try to login
// again

app.get('/login_failure', function(req, res) {
    res.render('login_failure');
});

// only users who can use the app during the beta period

var authorized_users = ["rick.mcgeer@gmail.com", "geeproject6@gmail.com", "rick.mcgeer@us-ignite.org",
                        "andybavier@gmail.com", "acb@cs.princeton.edu", "jack.brassil@comcast.net"];

// Successful login page.  Should be extensively modified.  Right now, shows a
// check-back-later page if the user isn't authorizes, and if it is
// shows the user two options: get a slicelet or free a slicelet, as URLs.
// Four things:
// 1. The UI elements should be buttons
// 2. The user name is an open parameter (should be in a cookie; this is insecure)
// 3.  Should show active slicelets and expiration times
// 4. Several more options should be added: Renew a slice, get credentials for an existing slicelet,
//    ...what else?

app.get('/logged_in', function(req, res) {
    var i = authorized_users.indexOf(user_email);
    if (i == -1) {
      res.render('unauthorized_user', {user:user_email});
    } else {
      var get_slicelet_url = application_url + "/get_slicelet?user=" + user_email;
      var free_slicelet_url = application_url + "/free_slicelet?user=" + user_email;
      res.render('logged_in', {user:user_email, get_url:get_slicelet_url, free_url:free_slicelet_url});
    }
});

// get a slicelet.  This just calls $ allocate-gee-slice.plcsh -- -e <user>.  This
// script returns a JSON object with two fields, user (the user email) and slicelet_file
// If the command fails, we tell the user, with the error message -- and should probably
// do more, like submit a bug report to ourselves, or give the user that option.
// If it succeeds, give the user a  URL which points to a download.

app.get('/get_slicelet', function(req, res) {
    console.log(req.url);
    var query = url.parse(req.url, true).query;
    console.log(JSON.stringify(query));
    var user_email = query.user;
    console.log(user_email);
    var spawn = require('child_process').spawn;
    var cmd = spawn('/home/service_instageni/allocate-gee-slice.plcsh', ["--", "-e", user_email]);
    /* var cmd = spawn('./gee-slicelet.py', [user_email]); */
    var returned_user = null;
    var download_file = null;
    var error = "";
    cmd.stdout.on('data', function (data) {
        console.log('stdout: ' + data);
        result = JSON.parse(data);
        returned_user = result.user;
        download_file = result.slicelet_file;
    });
    cmd.stderr.on('data', function (data) {
        console.log('stderr: ' + data);
        error = error + data;
    });
    cmd.on('close', function (code) {
        console.log('child process exited with code ' + code);
        // res.send("Completed with result: " + result + " error: " + error);
        if (download_file != null) {
            var download_url = application_url + '/download?file=' + download_file;
            res.render('download_template', {fields:{user:returned_user, download_url:download_url}});
        } else {
            res.send('Slicelet Allocation Failed for' + returned_user);
        }
    });
});

// free a slicelet.  This just calls $ free-gee-slice.plcsh -- -e <user>.  This
// script returns a JSON object with two fields, user (the user email) and slicelet_file
// Currently just tell the user what happened, not in an attractive way -- need to fix this

app.get('/free_slicelet', function(req, res) {
    console.log(req.url);
    var query = url.parse(req.url, true).query;
    console.log(JSON.stringify(query));
    var user_email = query.user;
    console.log(user_email);
    var spawn = require('child_process').spawn;
    var cmd = spawn('/home/service_instageni/free-gee-slice.plcsh', ["--", "-e", user_email]);
    /* var cmd = spawn('./gee-slicelet.py', [user_email]); */
    var error = "";
    var result = "";
    cmd.stdout.on('data', function (data) {
        console.log('stdout: ' + data);
        result = result + data;
    });
    cmd.stderr.on('data', function (data) {
        console.log('stderr: ' + data);
        error = error + data;
    });
    cmd.on('close', function (code) {
        console.log('child process exited with code ' + code);
        res.send("Completed with result: " + result + " error: " + error);
    });
});

// Callback for download.  Fortunately, this is simple, as node.js provides a
// download primitive.  We need to error-check this batter.
app.get('/download', function(req, res) {
    console.log(req.url);
    var query = url.parse(req.url, true).query;
    console.log(JSON.stringify(query));
    filename=query.file;
    console.log(filename);
    res.download(filename);
});

